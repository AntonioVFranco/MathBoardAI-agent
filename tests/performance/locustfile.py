""" Locust Load Testing Script for MathBoardAI Agent This script simulates concurrent users interacting with the MathBoardAI Agent Gradio application to test performance under various load conditions. Author: MathBoardAI Agent Team Task ID: TEST-003 """ import random import time import json import logging from typing import Dict, Any, List from locust import HttpUser, task, between, events from locust.exception import StopUser # Configure logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) # Test problem sets for different complexity levels class TestProblems: """Collection of mathematical problems for load testing.""" # Simple problems - quick parsing and solving SIMPLE_PROBLEMS = [ "Solve x + 5 = 10", "Simplify 2x + 3x", "Factor x^2 - 4", "Evaluate 3 + 4 * 2", "Find derivative of x^2", "Solve 2x = 8", "Simplify (x + 1)(x - 1)", "Evaluate integral of 2x dx" ] # Medium complexity problems - moderate processing time MEDIUM_PROBLEMS = [ "Find the determinant of [[2, 1], [3, 4]]", "Solve the system: 2x + y = 5, x - y = 1", "Calculate the derivative of sin(x^2) * cos(x)", "Find the integral of x * e^x dx from 0 to 1", "Compute eigenvalues of [[3, 1], [0, 2]]", "Minimize f(x) = x^2 - 4x + 5", "Calculate correlation between [1,2,3,4,5] and [2,4,6,8,10]", "Perform t-test on samples [1,2,3,4,5] and [2,3,4,5,6]" ] # Complex problems - high processing time and resource usage COMPLEX_PROBLEMS = [ "Perform SVD on matrix [[1,2,3,4,5],[2,4,6,8,10],[3,6,9,12,15],[4,8,12,16,20],[5,10,15,20,25]]", "Use gradient descent to minimize f(x,y) = (x-3)^2 + (y-2)^2 starting from (0,0)", "Find all critical points of f(x,y) = x^3 - 3x*y^2 + y^3", "Solve the optimization problem: minimize x^2 + y^2 subject to x + y = 1", "Calculate the QR decomposition of a 5x5 random matrix [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]", "Perform ANOVA on three groups: [85,88,92,78,91], [82,79,84,77,80], [90,93,89,95,87]", "Find the inverse of matrix [[2,1,3],[1,1,1],[1,2,1]] and verify A*A^(-1) = I", "Calculate descriptive statistics and normality test for data [12,15,18,14,16,13,17,19,11,20,22,16,14,18,15]" ] @classmethod def get_random_problem(cls, complexity: str = "medium") -> str: """Get a random problem of specified complexity.""" if complexity == "simple": return random.choice(cls.SIMPLE_PROBLEMS) elif complexity == "medium": return random.choice(cls.MEDIUM_PROBLEMS) elif complexity == "complex": return random.choice(cls.COMPLEX_PROBLEMS) else: # Random complexity all_problems = cls.SIMPLE_PROBLEMS + cls.MEDIUM_PROBLEMS + cls.COMPLEX_PROBLEMS return random.choice(all_problems) class MathAgentUser(HttpUser): """ Simulates a user interacting with the MathBoardAI Agent application. This user class defines various tasks that simulate real user behavior, including different types of mathematical problems with varying complexity. """ # Wait time between tasks (simulates user thinking/reading time) wait_time = between(1, 5) # Default API key for testing (should be set via environment or config) api_key = "sk-test-key-for-load-testing" def on_start(self): """Called when a user starts - setup user session.""" logger.info(f"User {self.client.base_url} starting session") # Try to get API key from environment import os self.api_key = os.getenv("OPENAI_API_KEY", "sk-test-key-for-load-testing") # Initialize session metrics self.successful_requests = 0 self.failed_requests = 0 self.total_response_time = 0 # Verify the application is accessible try: response = self.client.get("/", timeout=10) if response.status_code != 200: logger.error(f"Application not accessible: {response.status_code}") raise StopUser() except Exception as e: logger.error(f"Failed to connect to application: {e}") raise StopUser() def on_stop(self): """Called when a user stops - cleanup and logging.""" total_requests = self.successful_requests + self.failed_requests if total_requests > 0: success_rate = (self.successful_requests / total_requests) * 100 avg_response_time = self.total_response_time / total_requests if total_requests > 0 else 0 logger.info(f"User session ended - Success rate: {success_rate:.1f}%, " f"Avg response time: {avg_response_time:.2f}s") def _make_prediction_request(self, problem: str, complexity: str = "medium") -> Dict[str, Any]: """ Make a request to the Gradio prediction endpoint. Args: problem: Mathematical problem to solve complexity: Problem complexity level for metrics Returns: Response data and metrics """ start_time = time.time() try: # Gradio API endpoint format prediction_data = { "data": [self.api_key, problem], "fn_index": 0 # This may need adjustment based on Gradio setup } # Make the request with self.client.post( "/api/predict", json=prediction_data, headers={"Content-Type": "application/json"}, timeout=60, # 60 second timeout for complex problems catch_response=True ) as response: end_time = time.time() response_time = end_time - start_time self.total_response_time += response_time if response.status_code == 200: try: result = response.json() # Check if the response indicates success if "data" in result: # Check for error indicators in the response response_text = str(result.get("data", [""])[0]) if "" in response_text or "Error" in response_text: response.failure(f"Mathematical error returned: {response_text[:100]}") self.failed_requests += 1 else: response.success() self.successful_requests += 1 logger.debug(f"Successful {complexity} problem solved in {response_time:.2f}s") else: response.failure("No data in response") self.failed_requests += 1 except json.JSONDecodeError: response.failure("Invalid JSON response") self.failed_requests += 1 else: response.failure(f"HTTP {response.status_code}") self.failed_requests += 1 return { "status_code": response.status_code, "response_time": response_time, "complexity": complexity, "problem_length": len(problem) } except Exception as e: end_time = time.time() response_time = end_time - start_time self.total_response_time += response_time self.failed_requests += 1 logger.error(f"Request failed: {str(e)}") return { "status_code": 0, "response_time": response_time, "complexity": complexity, "error": str(e) } @task(3) def solve_simple_problem(self): """Task: Solve a simple mathematical problem (weight: 3).""" problem = TestProblems.get_random_problem("simple") logger.debug(f"Solving simple problem: {problem}") self._make_prediction_request(problem, "simple") @task(5) def solve_medium_problem(self): """Task: Solve a medium complexity problem (weight: 5).""" problem = TestProblems.get_random_problem("medium") logger.debug(f"Solving medium problem: {problem}") self._make_prediction_request(problem, "medium") @task(2) def solve_complex_problem(self): """Task: Solve a complex mathematical problem (weight: 2).""" problem = TestProblems.get_random_problem("complex") logger.debug(f"Solving complex problem: {problem}") self._make_prediction_request(problem, "complex") @task(1) def solve_linear_algebra_problem(self): """Task: Specifically test linear algebra operations (weight: 1).""" la_problems = [ "Calculate the determinant of [[1,2,3],[4,5,6],[7,8,9]]", "Find the inverse of [[2,1],[1,1]]", "Compute eigenvalues of [[4,1],[2,3]]", "Perform LU decomposition on [[3,2,1],[2,3,1],[1,2,3]]" ] problem = random.choice(la_problems) logger.debug(f"Solving linear algebra problem: {problem}") self._make_prediction_request(problem, "linear_algebra") @task(1) def solve_optimization_problem(self): """Task: Specifically test optimization operations (weight: 1).""" opt_problems = [ "Find the minimum of f(x) = x^2 - 6x + 9", "Use gradient descent to minimize f(x,y) = x^2 + y^2", "Find critical points of f(x) = x^3 - 3x^2 + 2", "Minimize f(x,y) = (x-1)^2 + (y-2)^2 subject to x + y = 3" ] problem = random.choice(opt_problems) logger.debug(f"Solving optimization problem: {problem}") self._make_prediction_request(problem, "optimization") @task(1) def solve_statistics_problem(self): """Task: Specifically test statistical operations (weight: 1).""" stats_problems = [ "Calculate mean and standard deviation of [10,12,14,16,18,20,22]", "Perform t-test comparing [1,2,3,4,5] and [3,4,5,6,7]", "Calculate correlation between [1,3,5,7,9] and [2,4,6,8,10]", "Test normality of data [12,15,13,18,16,14,17,19,11,20]" ] problem = random.choice(stats_problems) logger.debug(f"Solving statistics problem: {problem}") self._make_prediction_request(problem, "statistics") @task(1) def health_check(self): """Task: Simple health check of the application (weight: 1).""" try: with self.client.get("/", timeout=10, catch_response=True) as response: if response.status_code == 200: response.success() else: response.failure(f"Health check failed: {response.status_code}") except Exception as e: logger.error(f"Health check failed: {e}") # Event handlers for additional metrics and logging @events.request.add_listener def my_request_handler(request_type, name, response_time, response_length, response, context, exception, **kwargs): """Handle request events for custom metrics.""" if exception: logger.error(f"Request failed: {name} - {exception}") else: if response_time > 15000: # 15 seconds logger.warning(f"Slow request: {name} took {response_time}ms") @events.test_start.add_listener def on_test_start(environment, **kwargs): """Handle test start event.""" logger.info("Load test starting...") logger.info(f"Target host: {environment.host}") logger.info(f"User count: {environment.runner.target_user_count}") @events.test_stop.add_listener def on_test_stop(environment, **kwargs): """Handle test stop event.""" logger.info("Load test completed.") # Print summary statistics stats = environment.runner.stats logger.info(f"Total requests: {stats.total.num_requests}") logger.info(f"Failed requests: {stats.total.num_failures}") logger.info(f"Failure rate: {stats.total.fail_ratio:.2%}") logger.info(f"Average response time: {stats.total.avg_response_time:.2f}ms") logger.info(f"95th percentile response time: {stats.total.get_response_time_percentile(0.95):.2f}ms") # Custom load test patterns class StressTestUser(MathAgentUser): """ Specialized user for stress testing with more aggressive patterns. """ # Shorter wait times for stress testing wait_time = between(0.5, 2) @task(10) def rapid_fire_problems(self): """Rapidly submit multiple problems in succession.""" problems = [ TestProblems.get_random_problem("simple"), TestProblems.get_random_problem("medium"), TestProblems.get_random_problem("simple") ] for problem in problems: self._make_prediction_request(problem, "rapid_fire") time.sleep(0.1) # Brief pause between rapid requests class EnduranceTestUser(MathAgentUser): """ Specialized user for endurance testing with consistent load. """ # Consistent wait times for endurance testing wait_time = between(3, 3) @task(1) def consistent_medium_load(self): """Consistently submit medium complexity problems.""" problem = TestProblems.get_random_problem("medium") self._make_prediction_request(problem, "endurance") # Configuration for different test scenarios def get_user_class(test_type: str = "default"): """Get appropriate user class based on test type.""" if test_type == "stress": return StressTestUser elif test_type == "endurance": return EnduranceTestUser else: return MathAgentUser if __name__ == "__main__": # This allows the script to be run directly for debugging import sys logger.info("Locust file loaded successfully") logger.info("Available user classes: MathAgentUser, StressTestUser, EnduranceTestUser") logger.info("Usage: locust -f locustfile.py --host=http://localhost:7860")